---
title: "Mixed Models"
output:
  word_document: default
  pdf_document: default
date: "2022-10-17"
---
--------------------------------------------------------------------------------
Mixed Effects Models
--------------------------------------------------------------------------------
Need these packages:

install.packages("remotes")
remotes::install_github("easystats/report")

To use the package below

```{r}
library("report")
```

```{r, warning=FALSE}
x <- c("ggmap", "rgdal", "rgeos", "maptools", "dplyr", "tidyr", "tmap", "sf", "MASS", "rgeos", "gmt", "lme4", "lmerTest", "ggplot2", "sf", "tidyverse", "gganimate")
lapply(x, library, character.only = TRUE) 
```

```{r}
dataPop = read.csv("C:\\Users\\Laura\\OneDrive - Western Sydney University\\Spring 2022\\Final Project\\populationLong.csv")
```

```{r}
dataPop = subset(dataPop, select = -c(numChange,perChange) )
```

```{r}
dataPop$density <- 0.0    
dataPop$density <- dataPop$pop/dataPop$area
dataPop$yearsince2000 <- dataPop$year-2000
```

```{r}
dataPop$trans_density <- sqrt(dataPop$density)
```

```{r}
syd <- st_read("C:\\Users\\Laura\\OneDrive - Western Sydney University\\Spring 2022\\SA2_2016_AUST.shp")
greaterSyd <- syd[syd$GCC_NAME16=="Greater Sydney",]
```

```{r}
centr <- st_centroid(greaterSyd)
centroid_lat <- unlist(lapply(centr$geometry,function(l) l[2]))
centroid_long <- unlist(lapply(centr$geometry,function(l) l[1]))
```

```{r}
greaterSyd$sydist <- geodist(-33.8688,151.2093,centroid_lat,centroid_long)
greaterSyd$parradist <- geodist(-33.8148,151.0017,centroid_lat,centroid_long)
dataPop$sydist <- greaterSyd$sydist[match(dataPop$name,greaterSyd$SA2_NAME16)]
dataPop$parradist <- greaterSyd$parradist[match(dataPop$name,greaterSyd$SA2_NAME16)]
dataPop$logsydist <- log(greaterSyd$sydist[match(dataPop$name,greaterSyd$SA2_NAME16)])
dataPop$logparradist <- log(greaterSyd$parradist[match(dataPop$name,greaterSyd$SA2_NAME16)])
```

```{r}
# Drop SA2's without syddist
length(unique(dataPop$logsydist))
dataPop <- dataPop[!is.na(dataPop$logsydist),]
length(unique(dataPop$logsydist))
```

Mixed-Models:
A mixture of fixed and random. 

Fixed effects model.
```{r}
fit_fixed <- lm(trans_density~yearsince2000*logparradist+yearsince2000*logsydist,data=dataPop)
summary(fit_fixed)
```


Output Summary Interpretation:
I'm assuming we can interpret this in the same way we approached the linear
model. The only difference being the ways in which we examine the 
variables like yearsince2000:parradist and yearsince2000:sydist.

If so we can say this model performs poorly compared to the multiple linear 
regression and linear models above.

^ This performs similarly to the previous models. Accounting for roughly
59.51% of the variance in the data
The only concerning thing is that in both models yearsince2000:parradist
and yearsince2000:sydist are not apparently significant given their p-values. 


```{r}
report(fit_fixed)
```

Mixed Effect Model, Random Intercepts
```{r}
fit_randint <- lmer(trans_density~yearsince2000*logparradist*logsydist+(1|name),data=dataPop)
summary(fit_randint)
```
Summary analysis: 

```{r}
report(fit_randint)
```

```{r}
ranEff = ranef(fit_randint)$name
```

Random Intercept for each SA2  much bigger than residual variation
this model better than fixed effect.


Mixed Effect Model
```{r}
fit_randslope1 <- lmer(trans_density~yearsince2000*parradist*sydist+(yearsince2000|name),data=dataPop)
summary(fit_randslope1)
```

```{r}
report(fit_randslope1)
```


```{r}
ranEff = ranef(fit_randslope1)$name
ranEff
```

Intercept random effect is small. 


```{r}
anova(fit_randint,fit_randslope1)
```

Random slope model significantly better fit.


```{r}
dataPop$year2020 = (dataPop$yearsince2000 == 20)
dataPop$year2021= (dataPop$yearsince2000 == 21)
```


```{r}
head(dataPop,30)
```

```{r}
slopes_years_syd = lmer(trans_density ~ logsydist*yearsince2000 + logsydist*year2020 +  logsydist*year2021 + (yearsince2000|name),data=dataPop)
summary(slopes_years_syd)
report(slopes_years_syd)
```

Create a new df that holds samples to be plotted based on the model.
Here we have a data point close the Sydney, 2kms, and one far away from Sydney,
50kms.
We then choose to 

```{r}
df = expand.grid(logsydist=c(0.6340370,3.876380), yearsince2000=1.0:21.0)
df
```


Now use to ifelse statements to establish if the sample if from 2020 or 2021
```{r}
df$year2020 = ifelse(df$yearsince2000 == 20, TRUE, FALSE)
df$year2021 = ifelse(df$yearsince2000 == 21, TRUE, FALSE)
```


```{r}
df_predict = predict(slopes_years_syd, df, re.form=~0)
```

```{r}
plot(df$yearsince2000, df_predict**2)
```





Random slope with year= 2020 and year = 2021 as predictors
```{r}
slopes_years = lmer(trans_density ~ logsydist*logparradist*yearsince2000 + logsydist*logparradist*year2020 +  logsydist*logparradist*year2021 + (yearsince2000|name),data=dataPop)
summary(slopes_years)
#random_coef = coef(slopes_years)$name
#random_coef
#row.names(random_coef)
```


```{r}
greaterSyd$coef_slope <- random_coef$`(Intercept)`[match(unique(greaterSyd$SA2_NAME16),row.names(random_coef))]
qtm(shp = greaterSyd, fill = c("coef_slope"), fill.palette = "Purples", title = "Coeficient Heat Map (Slopes)")
```





Random int with year= 2020 and year = 2021 as predictors
```{r}
intercepts_years = lmer(trans_density ~ logsydist*logparradist*yearsince2000 + logsydist*logparradist*year2020 +  logsydist*logparradist*year2021 + (1|name),data=dataPop)
qqnorm(resid(intercepts_years))
qqline(resid(intercepts_years))
#plot(intercepts_years)
#summary(intercepts_years)
```

```{r}
print(intercepts_years, correlation=TRUE)
```


```{r}
report(intercepts_years)
```
```{r}
anova(intercepts_years, slopes_years)
```



```{r}
random_eff = ranef(intercepts_years)$name
random_eff
random_coef = coef(intercepts_years)$name
random_coef
```


```{r}
greaterSyd$coef <- random_coef$`(Intercept)`[match(unique(greaterSyd$SA2_NAME16),row.names(random_coef))]
qtm(shp = greaterSyd, fill = c("coef"), fill.palette = "Greens", title = "Coeficient Heat Map (Intercepts)")
```


================================================================================

Visualisation

Need this chunk to work for the next chunk
```{r}
fixed_effects = fixef(model_fit)
random_effects = 
  random_coef %>%
  mutate(name = factor(unique(dataPop$name)))
```


Since this SA2 data is from 2016 I can only really use SA2's with names consistent from 2016.
Drop missing ones?
This is an issue with trying to reproduce the next plot as well


Maybe try this with a simplier mixed model first

```{r}
dataPop %>% 
  ggplot(aes(logsydist, trans_density)) +
  geom_point(aes(color = 1), alpha = .25) +
  geom_abline(
    aes(
      intercept = fixed_effects['(Intercept)'],
      slope = fixed_effects['Sydney Dist']),
    color = 'darkred',
    size = 2) +
  geom_abline(
    aes(
      intercept = `(Intercept)`, 
      slope = logsydist,
      color = 1),
    size = .5,
    alpha = .25,
    data = random_effects) 
```



```{r}
# This is how I want to plot the random slopes
# Pretty sure
dataPop %>% 
  ggplot(aes(logsydist*logparradist*yearsince2000 + logsydist*logparradist*year2020 +  logsydist*logparradist*year2021, trans_density)) +
  geom_point(aes(color = name), alpha = .25) +
  geom_abline(
    aes(
      intercept = fixed_effects['(Intercept)'],
      slope = fixed_effects['Name']),
    color = 'darkred',
    size = 2) +
  geom_abline(
    aes(
      intercept = '(Intercept)', 
      slope = logsydist*logparradist*yearsince2000 + logsydist*logparradist*year2020 +  logsydist*logparradist*year2021,
      color = name),
    size = .5,
    alpha = .25,
    data = dataPop) 
```

================================================================================
Sample code

model_fit = lmer(trans_density ~ logsydist*logparradist*yearsince2000 + logsydist*logparradist*year2020 +  logsydist*logparradist*year2021 + (1|name),data=dataPop)
model_lm = lm(trans_density ~ logsydist + yearsince2000)

```{r}
model_lm = lm(trans_density ~ logsydist + yearsince2000, data = dataPop)
```


```{r}
gpa_lm_by_group0 = lmList(trans_density ~ yearsince2000 | name, dataPop)
gpa_lm_by_group  = coef(gpa_lm_by_group0)
gint = 
  data_frame(Mixed=coef(model_fit)$name[,1], Separate=gpa_lm_by_group[,1]) %>% 
  gather(key=Model, value=Intercept) %>% 
  ggplot(aes(x=Intercept)) +
  geom_density(aes(color=Model, fill=Model), alpha=.25) +
  scale_color_viridis_d(begin = .25, end = .75) +
  scale_fill_viridis_d(begin = .25, end = .75) +
  ggtitle('Intercepts') +
  labs(x='', y='') +
  xlim(c(1.5,4)) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.key.size=unit(2, 'mm'),
    legend.title=element_text(size=8),
    legend.text=element_text(size=8),
    legend.box.spacing=unit(0, 'in'),
    legend.position=c(.85,.75)
    )
gslopes = 
  data_frame(Mixed=coef(gpa_mixed)$student[,2], Separate=gpa_lm_by_group[,2]) %>% 
  gather(key=Model, value=Occasion) %>% 
  ggplot(aes(x=Occasion)) +
  geom_density(aes(color=Model, fill=Model), alpha=.25, show.legend=F) +
  scale_color_viridis_d(begin = .25, end = .75) +
  scale_fill_viridis_d(begin = .25, end = .75) +
  ggtitle('Slopes for occasion') +
  labs(x='', y='') +
  xlim(c(-.2,.4)) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )
library(patchwork)
gint + gslopes
```



```{r}
greaterSyd
```

```{r}
qtm(shp = greaterSyd, fill = c("parradist"), fill.palette = "Blues")
```

