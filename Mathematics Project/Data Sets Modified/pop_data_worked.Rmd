---
title: "R Notebook"
output: html_notebook
---



Required packages
```{r}
library("geosphere")
library("ggplot2")
library("ggmap")
library("tidyr")
library("ggplot2")
library('MASS')
```


This data has been modified to include the distance from Sydney for each SA2 region. 
Distance is calculated using geosphere which implements the haversine function. 
The accuracy is not necessarily precise giving the nature of the calculations. 
Distance may not be measured from the center of each SA2 region.
```{r}
# Population estimates by SA2 and above (ASGS2021), 2001 to 2021
df = read.csv("C:\\Users/Laura/OneDrive - Western Sydney University\\Spring 2022\\Mathematics Project\\Data Sets Modified\\Population_done.csv")
```

Check that the data has loaded in correctly 
```{r}
head(df,5)
```


For loop to correct the year column names. Want them to be numeric and not include 'X'
```{r}
for (x in 4:24){
  name = 1997 + x
  colnames(df)[x] <- name
}
```

Fixed
```{r}
head(df,5)
```

I'm not sure if there's a cleaner way to do this given the number of variables 
but here's the data in long formaat.
```{r}
df = df %>% pivot_longer(cols=c('2001', '2002', '2003', '2004', '2005', '2006', '2007', '2008', '2009', '2010',  '2011', '2012', '2013', '2014', '2015', '2016', '2017', '2018', '2019', '2020', '2021'),
                    names_to='year',
                    values_to='Pop')
```

```{r}
head(df,5)
dim(df)
```

Add new column for population density. Current one only accounts for 2021
Assigning the value to the new column values. Can't assign double values otherwise sine the column 
because type logical
```{r}
df['density_2'] <- 0.0
```


```{r}
head(df,4)
```

Calculate population density for each region for each year.
```{r}
for(x in 1:13503){
  pop_x = df[x,10]
  area_x = df[x,6]
  density_x = (pop_x/area_x)
  df[x,11] = density_x
}
```

```{r}
dim(df)
```


Need to remove Wollangambe - Wollemi samples since population = 0	
```{r}
new_df = df[!grepl(0, df$Pop),]
dim(new_df)
```

From the plot the data resembles a negative exponential function. 
It doesn't look positive or negatively linear. 
```{r}
plot(new_df$density_2 ~ new_df$year*(new_df$distance_from_syd))

```

Rough guestimate of what the function looks like.
Obviously most of our samples happen close to Sydney. City's tend to be more densely populated.
```{r}
t=0:2000
z= 33 + exp(10-(t/21))
plot(t,z, type="l", col="purple", lwd=5, main="Exponential decay")
```
Lets try a negative exponential model
Not quite sure this is the right way to run the model. 
```{r}
model_e = glm(density_2 ~ as.integer(year)*(distance_from_syd), data = new_df)
summary(model_e)
```



Plot the model
```{r}
plot(model_e)
```




```{r}
model_density = lm(density_2~as.integer(year)*(distance_from_syd) + (year=='2020')*(distance_from_syd), data = new_df)
summary(model_density)
```

Check the distribution of the distance from sydney variable 
```{r}
hist(new_df$density_2)


```






```{r}
y = new_df$density_2
x = as.integer(new_df$year)*(new_df$distance_from_syd)


bc <- boxcox(y ~ x)
(lambda <- bc$x[which.max(bc$y)])
```

```{r}
lambda = 0.1818182
new_model <- lm(((y^lambda-1)/lambda) ~ x)
```

```{r}
summary(new_model)
```


cox(model_2, data=new_df)
```

Normalize the data through log transformation. 
This may fix the issues regarding a lack of linear relationship between the variables.
```{r}
hist(sqrt(new_df$density_2))
hist(log(new_df$Area_Km2.))
hist(log(new_df$distance_from_syd))
```


```{r}
df[is.na(log(df$density_2)),]
```


```{r}
dens_omit= log(df$density_2)
sort(dens_omit)[1:5]
df[dens_omit==-Inf,]
```




```{r}
norm_model = lm(log(density_2)~(as.integer(year))*(log(distance_from_syd)), data=new_df)
```

```{r}
summary(norm_model)
```
```{r}
plot(norm_model)
```

Interpretation of plots:
1. Residuals vs Fitted


2.Normal Q-Q (Shows if the residuals are normally distributed)


3. Scaled-Location
Shows if residuals are spread equally along the ranges of predictors

4. Residuals vs Leverage 




Does the density variable need to normalised aswell?

```{r}
plot(log(new_df$density_2)~as.integer(new_df$year)*(log(new_df$distance_from_syd)))
```




Links:
Cox-box
https://www.statology.org/box-cox-transformation-in-r/

Model Plots
https://data.library.virginia.edu/diagnostic-plots/

